 /**
 * This file is part of Morphy library
 *
 * Copyright c 2007-2008 Kamaev Vladimir <heromantor@users.sourceforge.net>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

/**
 * This file is autogenerated at Wed, 14 Oct 2009 01:33:59 +0400, don`t change it!
 */
exports = module.exports = Fsa_Tree_File;

var js = require('../../jsutil');
var fs = require('fs');
var util = require('util');
var Buffer = require('buffer').Buffer;

function Fsa_Tree_File(resource, header) /*extends Morphy_Fsa*/ {
	this.alphabet = null;
	this.resource = resource;
	this.header = header;
	this.fsa_start = header['fsa_offset'];

	this.getRootTrans = function() {
		return this.root_trans;
	};

	this.getRootState = function() {
		return this.createState(this.getRootStateIndex());
	};

	this.getAlphabet = function() {
		if (!this.alphabet) {
			this.alphabet = str_split(this.readAlphabet());
		}

		return this.alphabet;
	};

	this.createState = function(index) {
		var fsa_state = require('../fsa/fsa_state');
		return new Morphy_State(this, index);
	};

	this.getRootStateIndex = function() {
		return 0;
	};

	this.readAlphabet = function() {
	};
	
    this.walk = function(trans, word, readAnnot/* = true*/) {
        if (!readAnnot)
            readAnnot = true;
    	var str = new Buffer(word);
		for (i = 0, c = str.length; i < c; i++) {
			prev_trans = trans;
			char = str[i];
            
            /////////////////////////////////
            // find char in state begin
			// tree version
			result = true;
			start_offset = this.fsa_start + (((trans >> 11) & 0x1FFFFF) << 2);
			
			// read first trans in state
			var buf = new Buffer(4);
			var readed = fs.readSync(this.resource, buf, 0,
					4, start_offset);
			trans = js.unpack('V', buf);
//			fseek(this.resource, start_offset); 
//			/*list(, trans) =*/ unpack('V', fread(this.resource, 4));
			
			// If first trans is term(i.e. pointing to annot) then skip it
			if((trans & 0x0100)) {
				// When this is single transition in state then break
				if((trans & 0x0200) && (trans & 0x0400)) {
					result = false;
				} else {
					start_offset += 4;
					var readed = fs.readSync(this.resource, buf, 0,
							4, start_offset);
					trans = js.unpack('V', buf);
					//fseek(this.resource, start_offset); 
//					/*list(, trans) =*/ unpack('V', fread(this.resource, 4));
				}
			}
			
			// if all ok process rest transitions in state
			if(result) {
				// walk through state
				for(idx = 1, j = 0; ; j++) {
					attr = (trans & 0xFF);
					
					if(attr == char) {
						result = true;
						break;
					} else if(attr > char) {
						if((trans & 0x0200)) {
							result = false;
							break;
						}
						
						idx = idx << 1;
					} else {
						if((trans & 0x0400)) {
							result = false;
							break;
						}
						
						idx = (idx << 1) + 1;
					}
					
					if(j > 255) {
						throw new Error('Infinite recursion possible');
					}
			
					 
					
					
					// read next trans
					var readed = fs.readSync(this.resource, buf, 0,
							4, start_offset + ((idx - 1) << 2));
					trans = js.unpack('V', buf);
//					fseek(this.resource, start_offset + ((idx - 1) << 2)); 
//					/*list(, trans) =*/ unpack('V', fread(this.resource, 4));
				}
			}
			
            // find char in state end
            /////////////////////////////////
            
            if(!result) {
                trans = prev_trans;
                break;
            }
        }
        
        annot = null;
        result = false;
        prev_trans = trans;
        
        if(i >= c) {
            // Read annotation when we walked all chars in word
            result = true;
            
            if(readAnnot) {
                // read annot trans
            	var buf = new Buffer(4);
    			var readed = fs.readSync(this.resource, buf, 0,
    					4, this.fsa_start + (((trans >> 11) & 0x1FFFFF) << 2));
    			trans = js.unpack('V', buf);
    			
//                fseek(this.resource, this.fsa_start + (((trans >> 11) & 0x1FFFFF) << 2)); 
//                /*list(, trans) =*/ unpack('V', fread(this.resource, 4));
                
                if(0 == (trans & 0x0100)) {
                    result = false;
                } else {
                    annot = this.getAnnot(trans);
                }
            }
        }
        
        return {
            'result' : result,
            'last_trans' : trans,
            'word_trans' : prev_trans,
            'walked' : i,
            'annot' : annot
        };
    };
    
    this.collect = function(startNode, callback, readAnnot /*= true*/, path /*= ''*/) {
        total = 0;
        
        stack = [];
        stack_idx = [];
        start_idx = 0;
        array_push(stack, null);
        array_push(stack_idx, null);
        
        state = this.readState(((startNode) >> 11) & 0x1FFFFF);
        
        do {
            for(i = start_idx, c = state.length; i < c; i++) {
                trans = state[i];
                
                if((trans & 0x0100)) {
                    total++;
                    
                    if(readAnnot) {
                        annot = this.getAnnot(trans);
                    } else {
                        annot = trans;
                    }
                    
                    if(!call_user_func(callback, path, annot)) {
                        return total;
                    }
                } else {
                    path += chr((trans & 0xFF));
                    array_push(stack, state);
                    array_push(stack_idx, i + 1);
                    state = this.readState(((trans) >> 11) & 0x1FFFFF);
                    start_idx = 0;
                    
                    break;
                }
            }
            
            if(i >= c) {
                state = array_pop(stack);
                start_idx = array_pop(stack_idx);
                path = path.substr(0, -1);
            }
        } while(!empty(stack));
        
        return total;
    };
    
    this.readState = function(index) {
        var result = [];
        
		offset = this.fsa_start + ((index) << 2);
		
		// read first trans
		fseek(this.resource, offset); 
		/*list(, trans) =*/ unpack('V', fread(this.resource, 4));
		
		// check if first trans is pointer to annot, and not single in state
		if((trans & 0x0100) && !((trans & 0x0200) || (trans & 0x0400))) {
			result.push(trans);
			
			/*list(, trans) =*/ unpack('V', fread(this.resource, 4));
			offset += 4;
		}
		
		// read rest
		for(expect = 1; expect; expect--) {
			if(!(trans & 0x0200)) expect++;
			if(!(trans & 0x0400)) expect++;
			
			result.push(trans);
			
			if(expect > 1) {
				trans = unpack('V', fread(this.resource, 4));
				offset += 4;
			}
		}
        
        return result;
    };
    
    this.unpackTranses = function(rawTranses) {
        settype(rawTranses, 'array');
        var result = [];
        
        for(var rawTrans in rawTranses) {
            result.push({
				'term'  : (rawTrans & 0x0100) ? true : false,
				'llast' : (rawTrans & 0x0200) ? true : false,
				'rlast' : (rawTrans & 0x0400) ? true : false,
				'attr'  : (rawTrans & 0xFF),
				'dest'  : ((rawTrans) >> 11) & 0x1FFFFF,
            });
        }
        
        return result;
    };
    
    this.readRootTrans = function() {
    	var buf = new Buffer(4);
		var readed = fs.readSync(this.resource, buf, 0, 4, this.fsa_start + 0);
		return js.unpack('V', buf);
    };
    
    this.readAlphabet = function() {

        fseek(this.resource, this.header['alphabet_offset']); 
        return fread(this.resource, this.header['alphabet_size']);
    };
    
    this.getAnnot = function(trans) {
        if(!(trans & 0x0100)) {
            return null;
        }
        
        offset =
            this.header['annot_offset'] +
            (((trans & 0xFF) << 21) | ((trans >> 11) & 0x1FFFFF));
        
        fseek(this.resource, offset); 
        len = ord(fread(this.resource, 1));
        
        if(len) {
            annot = fread(this.resource, len);
        } else {
            annot = null;
        }
        
        return annot;
    };
	this.root_trans = this.readRootTrans();
}
