 /**
 * This file is part of Morphy library
 *
 * Copyright c 2007-2008 Kamaev Vladimir <heromantor@users.sourceforge.net>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

/**
 * This file is autogenerated at Wed, 14 Oct 2009 01:34:00 +0400, don`t change it!
 */
var util = require('util');
var js = require('../../jsutil');
function Morphy_Graminfo_Mem(resource, header)/* extends Morphy_Graminfo*/ {
	
	this.resource = resource;
	this.header = header;
	this.ends = '\0\0' /*str_repeat("\0", header['char_size'] + 1)*/;
	this.ends_size = this.ends.length;
	
    this.getGramInfoHeaderSize = function() {
        return 20;
    }

    this.readGramInfoHeader = function(offset) {
        __mem = this.resource;
         
        
        result = unpack(
            'vid/vfreq/vforms_count/vpacked_forms_count/vancodes_count/vancodes_offset/vancodes_map_offset/vaffixes_offset/vaffixes_size/vbase_size',
            __mem.substr(offset, 20) 
        );
        
        result['offset'] = offset;
        
        return result;
    }

    this.readAncodesMap  = function(info) {
        // TODO: this can be wrong due to aligning ancodes map section
        offset = info['offset'] + 20 + info['forms_count'] * 2;
        forms_count = info['packed_forms_count'];
        return js.unpack("vforms_count",  this.resource.slice(offset, offset+forms_count * 2));
    }
    
    this.splitAncodes = function(ancodes, map) {
        var result = [];
        for(i = 0, c = map.length, j = 0; i <= c; i++) {
            res = [];

            for(k = 0, kc = map[i]; k < kc; k++, j++) {
                res.push(ancodes[j]);
            }
            if (res.length>0)
                result.push(res);
        }

        return result;
    };

    this.readAncodes = function(info) {
        // TODO: this can be wrong due to aligning ancodes section
        offset = info['offset'] + 20;
        forms_count = info['forms_count'];
        ancodes = js.unpack("vforms_count", this.resource.slice(offset, offset+ forms_count * 2));

        map = this.readAncodesMap(info);
        return this.splitAncodes(ancodes, map);
    }
    
    this.readFlexiaData = function(info) {

        offset = info['offset'] + 20;

        if(info['affixes_offset']) {
            offset += info['affixes_offset'];
        } else {
            offset += info['forms_count'] * 2 + info['packed_forms_count'] * 2;
        }
        
        var buf = this.resource.slice(offset, offset + info['affixes_size'] - this.ends_size)
        var result = buf.toString().split(this.ends);
        return result;
    }
    
    this.readAllGramInfoOffsets = function() {
        return this.readSectionIndex(this.header['flex_index_offset'], this.header['flex_count']);
    }

    this.readSectionIndex = function(offset, count) {
        __mem = this.resource;
        
         
        
        return array_values(unpack("Vcount", __mem.substr(offset, count * 4)));
    }

    this.readAllFlexia = function() {
        __mem = this.resource;
        var result = [];
        
        offset = this.header['flex_offset'];
        
        for(var size in this.readSectionIndexAsSize(this.header['flex_index_offset'], this.header['flex_count'], this.header['flex_size'])) {
            header = this.readGramInfoHeader(offset);
            affixes = this.readFlexiaData(header);
            ancodes = this.readAncodes(header, true);

            result[header['id']] = {
                'header' : header,
                'affixes' : affixes,
                'ancodes' : ancodes
            };

            offset += size;
        }

        return result;
    }
    
    this.readAllPartOfSpeech = function() {
        __mem = this.resource;
        
        var result = [];
        
        offset = this.header['poses_offset'];
        
        for(var size in this.readSectionIndexAsSize(this.header['poses_index_offset'], this.header['poses_count'], this.header['poses_size'])) {
             
            
            res = unpack(
                'vid/Cis_predict',
                __mem.substr(offset, 3) 
            );
            
            result[res['id']] = {
                'is_predict' : /*(bool)*/res['is_predict'],
                'name' : this.cleanupCString(__mem.substr(offset + 3, size - 3))
            };

            offset += size;
        }
        
        return result;
    }
    
    this.readAllGrammems = function() {
        __mem = this.resource;
        
        var result = [];
        
        offset = this.header['grammems_offset'];
        
        for(var size in this.readSectionIndexAsSize(this.header['grammems_index_offset'], this.header['grammems_count'], this.header['grammems_size'])) {
             
            
            res = unpack(
                'vid/Cshift',
                __mem.substr(offset, 3) 
            );
            
            result[res['id']] = {
                'shift' : res['shift'],
                'name' : this.cleanupCString(__mem.substr(offset + 3, size - 3))
            };

            offset += size;
        }
        
        return result;
    }

    this.readAllAncodes = function() {
        __mem = this.resource;
        
        var result = [];
        
        offset = this.header['ancodes_offset'];
         
        
        for(i = 0; i < this.header['ancodes_count']; i++) {
            res = unpack('vid/vpos_id', __mem.substr(offset, 4));
            offset += 4;
            
           /* list(, grammems_count) = */unpack('v', __mem.substr(offset, 2));
            offset += 2;
            
            result[res['id']] = {
                'pos_id' : res['pos_id'],
                'grammem_ids' : grammems_count ? 
                    array_values(unpack("vgrammems_count", __mem.substr(offset, grammems_count * 2))) :
                    {},
                'offset' : offset
            };
            
            offset += grammems_count * 2;
        }

        return result;
    }   
}
exports.Module = Morphy_Graminfo_Mem;
